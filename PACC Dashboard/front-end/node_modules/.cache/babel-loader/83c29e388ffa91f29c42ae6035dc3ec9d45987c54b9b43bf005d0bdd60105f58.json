{"ast":null,"code":"import { createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\";\nconst _hoisted_1 = {\n  class: \"chart-container\"\n};\nconst _hoisted_2 = {\n  ref: \"chartCanvas\"\n};\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"div\", _hoisted_1, [_createElementVNode(\"canvas\", _hoisted_2, null, 512 /* NEED_PATCH */)]);\n}","map":{"version":3,"names":["class","ref","_createElementBlock","_hoisted_1","_createElementVNode","_hoisted_2"],"sources":["D:\\develop\\vue-flask-dashboard\\front-end\\src\\views\\components\\GaugeComponent.vue"],"sourcesContent":["<template>\r\n  <div class=\"chart-container\">\r\n    <canvas ref=\"chartCanvas\"></canvas>\r\n  </div>\r\n</template>\r\n\r\n<script setup>\r\nimport { ref, onMounted, watch, defineProps, computed } from \"vue\";\r\nimport Chart from \"chart.js/auto\";\r\nimport ChartDataLabels from \"chartjs-plugin-datalabels\";\r\n\r\nconst props = defineProps({\r\n  totalSize: Number,\r\n  remainingSize: Number,\r\n  nodeName: String,\r\n});\r\n\r\nconst chartCanvas = ref(null);\r\nlet myChart = null;\r\n\r\nconst createChartData = (totalSize, remainingSize) => {\r\n  const usedSize = totalSize - remainingSize;\r\n  return {\r\n    labels: [\"Used\", \"Free\"],\r\n    datasets: [\r\n      {\r\n        label: \"Memory Usage\",\r\n        data: [usedSize, remainingSize],\r\n        backgroundColor: [\"#42A5F5\", \"#ddd\"],\r\n        borderWidth: 0,\r\n      },\r\n    ],\r\n  };\r\n};\r\n\r\nconst memoryUsageData = computed(() =>\r\n  createChartData(props.totalSize, props.remainingSize),\r\n); // Now using computed\r\n\r\n// Chart.js chart configuration\r\n// Chart.js chart configuration\r\nconst createChartConfig = (chartData, nodeName) => {\r\n  const totalSize = chartData.datasets[0].data.reduce((a, b) => a + b, 0);\r\n\r\n  return {\r\n    type: \"doughnut\",\r\n    data: chartData,\r\n    options: {\r\n      responsive: true,\r\n      maintainAspectRatio: false,\r\n      cutout: \"50%\", // You may adjust this for better label positioning\r\n      animation: {\r\n        animateRotate: true,\r\n        animateScale: false,\r\n      },\r\n      circumference: 180,\r\n      rotation: 270,\r\n      plugins: {\r\n        tooltip: {\r\n          enabled: false, // Disable default tooltips\r\n        },\r\n        datalabels: {\r\n          color: \"#000000\", // Set color of the labels\r\n          textAlign: \"center\",\r\n          font: {\r\n            weight: \"bold\",\r\n            size: 18,\r\n          },\r\n          formatter: (value, context) => {\r\n    // Display integer values instead of decimals\r\n    if (context.dataIndex === 0) {\r\n      // Used memory label\r\n      return parseInt(value) + \"MB\";\r\n    } else {\r\n      // Remaining memory label\r\n      return parseInt(value) + \"MB\";\r\n    }\r\n  },\r\n          anchor: \"center\",\r\n          align: \"center\",\r\n          offset: -10, // Adjust offset as needed\r\n          labels: {\r\n            title: {\r\n              font: {\r\n                size: '18'\r\n              }\r\n            },\r\n            value: {\r\n              color: 'black'\r\n            }\r\n          }\r\n        },\r\n        // Additional configuration for the center label\r\n        centerLabel: {\r\n          color: '#FF6384',\r\n          font: {\r\n            weight: 'bold',\r\n            size: '20' // Size of the center label\r\n          },\r\n          // You could create a custom plugin to handle this but for simplicity, we're defining the style here\r\n        },\r\n        title: {\r\n          display: true,\r\n          text: nodeName,\r\n          position: \"top\",\r\n          color: \"#666\",\r\n          font: {\r\n            size: 16,\r\n          },\r\n        },\r\n      },\r\n    },\r\n    plugins: [ChartDataLabels, {\r\n      // Plugin to render the center label\r\n      afterDraw: chart => {\r\n        let ctx = chart.ctx;\r\n        ctx.save();\r\n        const centerLabel = ((chartData.datasets[0].data[0] / totalSize) * 100).toFixed(2) + '%'; // Calculate percentage\r\n        const centerX = (chart.chartArea.left + chart.chartArea.right) / 2;\r\n        const centerY =chart.chartArea.bottom -40 ;\r\n        ctx.font = '30px Arial';\r\n        ctx.textAlign = 'center';\r\n        ctx.textBaseline = 'middle';\r\n        ctx.fillStyle = '90ee90'; // Center label color\r\n        ctx.fillText(centerLabel, centerX, centerY);\r\n        ctx.restore();\r\n      }\r\n    }], // Register the plugin here\r\n  };\r\n};\r\n\r\n\r\nonMounted(() => {\r\n  if (chartCanvas.value) {\r\n    const context = chartCanvas.value.getContext('2d');\r\n    if (context) {\r\n      const config = createChartConfig(memoryUsageData.value, props.nodeName);\r\n      myChart = new Chart(context, config);\r\n    } else {\r\n      console.error('Failed to get canvas context');\r\n    }\r\n  } else {\r\n    console.error('Canvas element not found');\r\n  }\r\n});\r\n\r\nwatch(() => [props.totalSize, props.remainingSize], (newValues) => {\r\n  if (myChart) {\r\n    const newChartData = createChartData(...newValues);\r\n    myChart.data = newChartData;\r\n    myChart.options = createChartConfig(newChartData, props.nodeName).options;\r\n    myChart.update();\r\n  }\r\n}, { immediate: true });\r\n</script>\r\n\r\n<style>\r\n.chart-container {\r\n  overflow: visible; /* Ensures no clipping */\r\n  opacity: 1; /* Checks that it's not hidden */\r\n  position: relative;\r\n  height: 40vh;\r\n  width: 80vw;\r\n}\r\n</style>\r\n"],"mappings":";;EACOA,KAAK,EAAC;AAAiB;;EAClBC,GAAG,EAAC;AAAa;;uBAD3BC,mBAAA,CAEM,OAFNC,UAEM,GADJC,mBAAA,CAAmC,UAAnCC,UAAmC,8B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}